{"version":3,"sources":["webpack://7zip.html/./node_modules/libarchive.js/src/compressed-file.js","webpack://7zip.html/./node_modules/libarchive.js/src/libarchive.js","webpack://7zip.html/./node_modules/uuid/dist/esm-browser/rng.js","webpack://7zip.html/./node_modules/uuid/dist/esm-browser/regex.js","webpack://7zip.html/./node_modules/uuid/dist/esm-browser/validate.js","webpack://7zip.html/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://7zip.html/./node_modules/uuid/dist/esm-browser/v4.js","webpack://7zip.html/./src/scripts/index.js"],"names":["CompressedFile","name","size","path","archiveRef","this","_name","_size","_path","_archiveRef","extractSingleFile","Archive","options","_options","workerUrl","file","init","console","warn","open","_worker","Worker","addEventListener","_workerMsg","bind","_callbacks","_content","_processed","_file","_postMessage","type","resolve","reject","msg","status","archivePassword","passphrase","Promise","then","entry","target","prop","_getProp","fileName","_cloneContent","getFilesObject","obj","_objectToArray","File","fileData","extractCallback","undefined","setTimeout","terminate","o","Object","keys","files","key","push","parts","split","length","pop","cur","prev","part","callback","postMessage","_msgHandler","error","data","getRandomValues","rnds8","Uint8Array","rng","crypto","msCrypto","Error","uuid","byteToHex","i","toString","substr","buf","offset","rnds","random","arr","arguments","toLowerCase","TypeError","textarea","document","getElementById","fileInput","treeView","walk","node","liId","root","li","createElement","e","stopPropagation","innerText","reader","FileReader","onload","event","textContent","result","readAsText","appendChild","newUlId","uuidv4","newUl","classList","add","id","newLi","preventDefault","childNodes","forEach","c","contains","toggle","span","innerHTML","location","href","fetch","response","blob","async","archive","extractFiles","currentTarget"],"mappings":"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","file":"js/app.423928a2.js","sourcesContent":["\r\n/**\r\n * Represents compressed file before extraction\r\n */\r\nexport class CompressedFile{\r\n\r\n    constructor(name,size,path,archiveRef){\r\n        this._name = name;\r\n        this._size = size;\r\n        this._path = path;\r\n        this._archiveRef = archiveRef;\r\n    }\r\n\r\n    /**\r\n     * file name\r\n     */\r\n    get name(){\r\n        return this._name;\r\n    }\r\n    /**\r\n     * file size\r\n     */\r\n    get size(){\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Extract file from archive\r\n     * @returns {Promise<File>} extracted file\r\n     */\r\n    extract(){\r\n        return this._archiveRef.extractSingleFile(this._path);\r\n    }\r\n\r\n}","import { CompressedFile } from \"./compressed-file.js\";\r\n\r\n\r\nexport class Archive{\r\n\r\n    /**\r\n     * Initialize libarchivejs\r\n     * @param {Object} options \r\n     */\r\n    static init(options = {}){\r\n        Archive._options = {\r\n            workerUrl: '../dist/worker-bundle.js',\r\n            ...options\r\n        };\r\n        return Archive._options;\r\n    }\r\n\r\n    /**\r\n     * Creates new archive instance from browser native File object\r\n     * @param {File} file\r\n     * @param {object} options\r\n     * @returns {Archive}\r\n     */\r\n    static open(file, options = null){\r\n        options =   options || \r\n                    Archive._options || \r\n                    Archive.init() && console.warn('Automatically initializing using options: ', Archive._options);\r\n        const arch = new Archive(file,options);\r\n        return arch.open();\r\n    }\r\n\r\n    /**\r\n     * Create new archive\r\n     * @param {File} file \r\n     * @param {Object} options \r\n     */\r\n    constructor(file,options){\r\n        this._worker = new Worker(options.workerUrl);\r\n        this._worker.addEventListener('message', this._workerMsg.bind(this));\r\n        this._callbacks = [];\r\n        this._content = {};\r\n        this._processed = 0;\r\n        this._file = file;\r\n    }\r\n\r\n    /**\r\n     * Prepares file for reading\r\n     * @returns {Promise<Archive>} archive instance\r\n     */\r\n    async open(){\r\n        await this._postMessage({type: 'HELLO'},(resolve,reject,msg) => {\r\n            if( msg.type === 'READY' ){\r\n                resolve();\r\n            }\r\n        });\r\n        return await this._postMessage({type: 'OPEN', file: this._file}, (resolve,reject,msg) => {\r\n            if(msg.type === 'OPENED'){\r\n                resolve(this);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * detect if archive has encrypted data\r\n     * @returns {boolean|null} null if could not be determined\r\n     */\r\n    hasEncryptedData(){\r\n        return this._postMessage({type: 'CHECK_ENCRYPTION'}, \r\n            (resolve,reject,msg) => {\r\n                if( msg.type === 'ENCRYPTION_STATUS' ){\r\n                    resolve(msg.status);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * set password to be used when reading archive\r\n     */\r\n    usePassword(archivePassword){\r\n        return this._postMessage({type: 'SET_PASSPHRASE', passphrase: archivePassword},\r\n            (resolve,reject,msg) => {\r\n                if( msg.type === 'PASSPHRASE_STATUS' ){\r\n                    resolve(msg.status);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns object containing directory structure and file information \r\n     * @returns {Promise<object>}\r\n     */\r\n    getFilesObject(){\r\n        if( this._processed > 0 ){\r\n            return Promise.resolve().then( () => this._content );\r\n        }\r\n        return this._postMessage({type: 'LIST_FILES'}, (resolve,reject,msg) => {\r\n            if( msg.type === 'ENTRY' ){\r\n                const entry = msg.entry;\r\n                const [ target, prop ] = this._getProp(this._content,entry.path);\r\n                if( entry.type === 'FILE' ){\r\n                    target[prop] = new CompressedFile(entry.fileName,entry.size,entry.path,this);                    \r\n                }\r\n                return true;\r\n            }else if( msg.type === 'END' ){\r\n                this._processed = 1;\r\n                resolve(this._cloneContent(this._content));\r\n            }\r\n        });\r\n    }\r\n\r\n    getFilesArray(){\r\n        return this.getFilesObject().then( (obj) => {\r\n            return this._objectToArray(obj);\r\n        });\r\n    }\r\n\r\n    extractSingleFile(target){\r\n        return this._postMessage({type: 'EXTRACT_SINGLE_FILE', target: target}, \r\n            (resolve,reject,msg) => {\r\n                if( msg.type === 'FILE' ){\r\n                    const file = new File([msg.entry.fileData], msg.entry.fileName, {\r\n                        type: 'application/octet-stream'\r\n                    });\r\n                    resolve(file);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns object containing directory structure and extracted File objects \r\n     * @param {Function} extractCallback\r\n     * \r\n     */\r\n    extractFiles(extractCallback){\r\n        if( this._processed > 1 ){\r\n            return Promise.resolve().then( () => this._content );\r\n        }\r\n        return this._postMessage({type: 'EXTRACT_FILES'}, (resolve,reject,msg) => {\r\n            if( msg.type === 'ENTRY' ){\r\n                const [ target, prop ] = this._getProp(this._content,msg.entry.path);\r\n                if( msg.entry.type === 'FILE' ){\r\n                    target[prop] = new File([msg.entry.fileData], msg.entry.fileName, {\r\n                        type: 'application/octet-stream'\r\n                    });\r\n                    if (extractCallback !== undefined) {\r\n                        setTimeout(extractCallback.bind(null,{\r\n                            file: target[prop],\r\n                            path: msg.entry.path,\r\n                        }));\r\n                    }\r\n                }\r\n                return true;\r\n            }else if( msg.type === 'END' ){\r\n                this._processed = 2;\r\n                this._worker.terminate();\r\n                resolve(this._cloneContent(this._content));\r\n            }\r\n        });\r\n    }\r\n\r\n    _cloneContent(obj){\r\n        if( obj instanceof File || obj instanceof CompressedFile || obj === null ) return obj;\r\n        const o = {};\r\n        for( const prop of Object.keys(obj) ){\r\n            o[prop] = this._cloneContent(obj[prop]);\r\n        }\r\n        return o;\r\n    }\r\n\r\n    _objectToArray(obj,path = ''){\r\n        const files = [];\r\n        for( const key of Object.keys(obj) ){\r\n            if( obj[key] instanceof File || obj[key] instanceof CompressedFile || obj[key] === null ){\r\n                files.push({\r\n                    file: obj[key] || key,\r\n                    path: path\r\n                });\r\n            }else{\r\n                files.push( ...this._objectToArray(obj[key],`${path}${key}/`) );\r\n            }\r\n        }\r\n        return files;\r\n    }\r\n\r\n    _getProp(obj,path){\r\n        const parts = path.split('/');\r\n        if( parts[parts.length -1] === '' ) parts.pop();\r\n        let cur = obj, prev = null;\r\n        for( const part of parts ){\r\n            cur[part] = cur[part] || {};\r\n            prev = cur;\r\n            cur = cur[part];\r\n        }\r\n        return [ prev, parts[parts.length-1] ];\r\n    }\r\n\r\n    _postMessage(msg,callback){\r\n        this._worker.postMessage(msg);\r\n        return new Promise((resolve,reject) => {\r\n            this._callbacks.push( this._msgHandler.bind(this,callback,resolve,reject) );\r\n        });\r\n    }\r\n\r\n    _msgHandler(callback,resolve,reject,msg){\r\n        if( msg.type === 'BUSY' ){\r\n            reject('worker is busy');\r\n        }else if( msg.type === 'ERROR' ){\r\n            reject(msg.error);\r\n        }else{\r\n            return callback(resolve,reject,msg);\r\n        }\r\n    }\r\n\r\n    _workerMsg({data: msg}){\r\n        const callback = this._callbacks[this._callbacks.length -1];\r\n        const next = callback(msg);\r\n        if( !next ){\r\n            this._callbacks.pop();\r\n        }\r\n    }\r\n\r\n}","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","\nimport '../styles/index.scss';\n\nimport {\n    Archive\n} from 'libarchive.js/main.js';\n\nimport {\n    v4 as uuidv4\n} from 'uuid';\n\nconst textarea = document.getElementById('fileOutput');\nconst fileInput = document.getElementById('fileInput');\nconst treeView = document.getElementById('treeView');\n\nArchive.init({\n    workerUrl: 'public/worker-bundle.js',\n});\n\nif (location.href.split('?archiveUrl=')[1]) {\n    fetch(location.href.split('?archiveUrl=')[1]).then(response => {\n            return response.blob();\n        })\n        .then(async (blob) => {\n            const archive = await Archive.open(blob);\n            let obj = await archive.extractFiles();\n            treeView.innerHTML = '';\n            walk({\n                node: obj,\n                liId: 'treeView',\n                name: 'externalArchive'\n            });\n        });\n}\n\nfileInput.addEventListener('change', async (e) => {\n    const file = e.currentTarget.files[0];\n    const archive = await Archive.open(file);\n    let obj = await archive.extractFiles();\n    treeView.innerHTML = '';\n    walk({\n        node: obj,\n        liId: 'treeView',\n        name: file.name\n    });\n});\n\nfunction walk({\n    node,\n    liId,\n    name\n}) {\n    const root = document.getElementById(liId);\n    if (!(node instanceof File)) {\n        const newUlId = uuidv4();\n        const newUl = document.createElement('ul');\n        newUl.classList.add('nested');\n        newUl.id = newUlId;\n        const newLi = document.createElement('li');\n        root.appendChild(newLi);\n        newLi.classList.add('folder');\n        newLi.addEventListener(\"click\", function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            newLi.childNodes.forEach(c => {\n                if (c.classList.contains('nested')) {\n                    c.classList.toggle(\"active\");\n                }\n            });\n        });\n\n        const span = document.createElement('span');\n        span.innerText = name;\n        newLi.appendChild(span);\n        newLi.appendChild(newUl);\n        const keys = Object.keys(node);\n        if (keys.length > 0) {\n            keys.forEach((key) => {\n                walk({\n                    node: node[key],\n                    liId: newUlId,\n                    name: key\n                });\n            });\n        } else {\n            const span = document.createElement('span');\n            span.innerHTML = '<i>Empty folder</i>';\n            root.appendChild(span);\n        }\n    } else {\n        const li = document.createElement('li');\n        li.addEventListener('click', function(e) {\n            e.stopPropagation();\n        });\n        li.innerText = node.name;\n        li.addEventListener('click', () => {\n            const reader = new FileReader();\n            reader.onload = function(event) {\n                textarea.textContent = event.target.result;\n            };\n            reader.readAsText(node);\n        });\n        root.appendChild(li);\n    }\n}"],"sourceRoot":""}